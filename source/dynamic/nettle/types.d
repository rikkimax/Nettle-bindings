/*

Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.

*/
module derelict.nettle.types;
struct aes_ctx
{
    uint32_t [60]keys;
    uint nrounds;
}

struct base16_decode_ctx
{
    uint word;
    uint bits;
}

struct base64_encode_ctx
{
    uint word;
    uint bits;
}
struct base64_decode_ctx
{
    uint word;
    uint bits;
    uint padding;
}

struct blowfish_ctx
{
    uint32_t [256][4]s;
    uint32_t [18]p;
}

struct des_ctx
{
    uint32_t [32]key;
}
struct des3_ctx
{
    des_ctx [3]des;
}

struct dsa_public_key
{
    mpz_t p;
    mpz_t q;
    mpz_t g;
    mpz_t y;
}
struct dsa_private_key
{
    mpz_t x;
}
struct dsa_signature
{
    mpz_t r;
    mpz_t s;
}
int  nettle_dsa_sha1_sign(dsa_public_key *pub, dsa_private_key *key, void *random_ctx, void  function(void *ctx, uint length, uint8_t *dst)random, sha1_ctx *hash, dsa_signature *signature);
int  nettle_dsa_sha256_sign(dsa_public_key *pub, dsa_private_key *key, void *random_ctx, void  function(void *ctx, uint length, uint8_t *dst)random, sha256_ctx *hash, dsa_signature *signature);
int  nettle_dsa_sha1_sign_digest(dsa_public_key *pub, dsa_private_key *key, void *random_ctx, void  function(void *ctx, uint length, uint8_t *dst)random, uint8_t *digest, dsa_signature *signature);
int  nettle_dsa_sha256_sign_digest(dsa_public_key *pub, dsa_private_key *key, void *random_ctx, void  function(void *ctx, uint length, uint8_t *dst)random, uint8_t *digest, dsa_signature *signature);
int  nettle_dsa_generate_keypair(dsa_public_key *pub, dsa_private_key *key, void *random_ctx, void  function(void *ctx, uint length, uint8_t *dst)random, void *progress_ctx, void  function(void *ctx, int c)progress, uint p_bits, uint q_bits);
int  _nettle_dsa_sign(dsa_public_key *pub, dsa_private_key *key, void *random_ctx, void  function(void *ctx, uint length, uint8_t *dst)random, uint digest_size, uint8_t *digest, dsa_signature *signature);

alias int time_t;
struct nettle_cipher
{
    char *name;
    uint context_size;
    uint block_size;
    uint key_size;
    void  function(void *ctx, uint length, uint8_t *key)set_encrypt_key;
    void  function(void *ctx, uint length, uint8_t *key)set_decrypt_key;
    void  function(void *ctx, uint length, uint8_t *dst, uint8_t *src)encrypt;
    void  function(void *ctx, uint length, uint8_t *dst, uint8_t *src)decrypt;
}
extern const nettle_cipher *[]nettle_ciphers;
extern const nettle_cipher nettle_aes128;
extern const nettle_cipher nettle_aes192;
extern const nettle_cipher nettle_aes256;
extern const nettle_cipher nettle_arcfour128;
extern const nettle_cipher nettle_camellia128;
extern const nettle_cipher nettle_camellia192;
extern const nettle_cipher nettle_camellia256;
extern const nettle_cipher nettle_cast128;
extern const nettle_cipher nettle_serpent128;
extern const nettle_cipher nettle_serpent192;
extern const nettle_cipher nettle_serpent256;
extern const nettle_cipher nettle_twofish128;
extern const nettle_cipher nettle_twofish192;
extern const nettle_cipher nettle_twofish256;
extern const nettle_cipher nettle_arctwo40;
extern const nettle_cipher nettle_arctwo64;
extern const nettle_cipher nettle_arctwo128;
extern const nettle_cipher nettle_arctwo_gutmann128;
struct nettle_hash
{
    char *name;
    uint context_size;
    uint digest_size;
    uint block_size;
    void  function(void *ctx)init;
    void  function(void *ctx, uint length, uint8_t *src)update;
    void  function(void *ctx, uint length, uint8_t *dst)digest;
}
extern const nettle_hash *[]nettle_hashes;
extern const nettle_hash nettle_md2;
extern const nettle_hash nettle_md4;
extern const nettle_hash nettle_md5;
extern const nettle_hash nettle_gosthash94;
extern const nettle_hash nettle_ripemd160;
extern const nettle_hash nettle_sha1;
extern const nettle_hash nettle_sha224;
extern const nettle_hash nettle_sha256;
extern const nettle_hash nettle_sha384;
extern const nettle_hash nettle_sha512;
extern const nettle_hash nettle_sha3_224;
extern const nettle_hash nettle_sha3_256;
extern const nettle_hash nettle_sha3_384;
extern const nettle_hash nettle_sha3_512;
struct nettle_armor
{
    char *name;
    uint encode_context_size;
    uint decode_context_size;
    uint encode_final_length;
    void  function(void *ctx)encode_init;
    uint  function(uint length)encode_length;
    uint  function(void *ctx, uint8_t *dst, uint src_length, uint8_t *src)encode_update;
    uint  function(void *ctx, uint8_t *dst)encode_final;
    void  function(void *ctx)decode_init;
    uint  function(uint length)decode_length;
    int  function(void *ctx, uint *dst_length, uint8_t *dst, uint src_length, uint8_t *src)decode_update;
    int  function(void *ctx)decode_final;
}
extern const nettle_armor *[]nettle_armors;
extern const nettle_armor nettle_base64;
extern const nettle_armor nettle_base16;
int  nettle_pgp_put_public_rsa_key(nettle_buffer *, rsa_public_key *key, time_t timestamp);
enum pgp_lengths
{
    PGP_LENGTH_ONE_OCTET,
    PGP_LENGTH_TWO_OCTETS = 192,
    PGP_LENGTH_FOUR_OCTETS = 8384,
}
enum pgp_public_key_algorithm
{
    PGP_RSA = 1,
    PGP_RSA_ENCRYPT,
    PGP_RSA_SIGN,
    PGP_EL_GAMAL_ENCRYPT = 16,
    PGP_DSA,
    PGP_EL_GAMAL = 20,
}
enum pgp_symmetric_algorithm
{
    PGP_PLAINTEXT,
    PGP_IDEA,
    PGP_3DES,
    PGP_CAST5,
    PGP_BLOWFISH,
    PGP_SAFER_SK,
    PGP_AES128 = 7,
    PGP_AES192,
    PGP_AES256,
}
enum pgp_compression_algorithm
{
    PGP_UNCOMPRESSED,
    PGP_ZIP,
    PGP_ZLIB,
}
enum pgp_hash_algorithm
{
    PGP_MD5 = 1,
    PGP_SHA1,
    PGP_RIPEMD,
    PGP_MD2 = 5,
    PGP_TIGER192,
    PGP_HAVAL,
}
enum pgp_tag
{
    PGP_TAG_PUBLIC_SESSION_KEY = 1,
    PGP_TAG_SIGNATURE,
    PGP_TAG_SYMMETRIC_SESSION_KEY,
    PGP_TAG_ONE_PASS_SIGNATURE,
    PGP_TAG_SECRET_KEY,
    PGP_TAG_PUBLIC_KEY,
    PGP_TAG_SECRET_SUBKEY,
    PGP_TAG_COMPRESSED,
    PGP_TAG_ENCRYPTED,
    PGP_TAG_MARKER,
    PGP_TAG_LITERAL,
    PGP_TAG_TRUST,
    PGP_TAG_USERID,
    PGP_TAG_PUBLIC_SUBKEY,
}
enum pgp_signature_type
{
    PGP_SIGN_BINARY,
    PGP_SIGN_TEXT,
    PGP_SIGN_STANDALONE,
    PGP_SIGN_CERTIFICATION = 16,
    PGP_SIGN_CERTIFICATION_PERSONA,
    PGP_SIGN_CERTIFICATION_CASUAL,
    PGP_SIGN_CERTIFICATION_POSITIVE,
    PGP_SIGN_SUBKEY = 24,
    PGP_SIGN_KEY = 31,
    PGP_SIGN_REVOCATION,
    PGP_SIGN_REVOCATION_SUBKEY = 40,
    PGP_SIGN_REVOCATION_CERTIFICATE = 48,
    PGP_SIGN_TIMESTAMP = 64,
}
enum pgp_subpacket_tag
{
    PGP_SUBPACKET_CREATION_TIME = 2,
    PGP_SUBPACKET_SIGNATURE_EXPIRATION_TIME,
    PGP_SUBPACKET_EXPORTABLE_CERTIFICATION,
    PGP_SUBPACKET_TRUST_SIGNATURE,
    PGP_SUBPACKET_REGULAR_EXPRESSION,
    PGP_SUBPACKET_REVOCABLE,
    PGP_SUBPACKET_KEY_EXPIRATION_TIME = 9,
    PGP_SUBPACKET_PLACEHOLDER,
    PGP_SUBPACKET_PREFERRED_SYMMETRIC_ALGORITHMS,
    PGP_SUBPACKET_REVOCATION_KEY,
    PGP_SUBPACKET_ISSUER_KEY_ID = 16,
    PGP_SUBPACKET_NOTATION_DATA = 20,
    PGP_SUBPACKET_PREFERRED_HASH_ALGORITHMS,
    PGP_SUBPACKET_PREFERRED_COMPRESSION_ALGORITHMS,
    PGP_SUBPACKET_KEY_SERVER_PREFERENCES,
    PGP_SUBPACKET_PREFERRED_KEY_SERVER,
    PGP_SUBPACKET_PRIMARY_USER_ID,
    PGP_SUBPACKET_POLICY_URL,
    PGP_SUBPACKET_KEY_FLAGS,
    PGP_SUBPACKET_SIGNERS_USER_ID,
    PGP_SUBPACKET_REASON_FOR_REVOCATION,
}

struct md5_ctx
{
    uint32_t [4]state;
    uint32_t count_low;
    uint32_t count_high;
    uint8_t [64]block;
    uint index;
}
struct sha1_ctx
{
    uint32_t [5]state;
    uint32_t count_low;
    uint32_t count_high;
    uint8_t [64]block;
    uint index;
}
struct sha256_ctx
{
    uint32_t [8]state;
    uint32_t count_low;
    uint32_t count_high;
    uint8_t [64]block;
    uint index;
}
struct sha512_ctx
{
    uint64_t [8]state;
    uint64_t count_low;
    uint64_t count_high;
    uint8_t [128]block;
    uint index;
}
struct rsa_public_key
{
    uint size;
    mpz_t n;
    mpz_t e;
}
struct rsa_private_key
{
    uint size;
    mpz_t d;
    mpz_t p;
    mpz_t q;
    mpz_t a;
    mpz_t b;
    mpz_t c;
}
int  nettle_rsa_generate_keypair(rsa_public_key *pub, rsa_private_key *key, void *random_ctx, void  function(void *ctx, uint length, uint8_t *dst)random, void *progress_ctx, void  function(void *ctx, int c)progress, uint n_size, uint e_size);

struct twofish_ctx
{
    uint32_t [40]keys;
    uint32_t [256][4]s_box;
}

alias void function(void *ctx, uint length, uint8_t *dst)nettle_random_func;
alias void function(void *ctx, int c)nettle_progress_func;
alias void *function(void *ctx, void *p, uint length)nettle_realloc_func;
alias void function(void *ctx, uint length, uint8_t *key)nettle_set_key_func;
alias void function(void *ctx, uint length, uint8_t *dst, uint8_t *src)nettle_crypt_func;
alias void function(void *ctx)nettle_hash_init_func;
alias void function(void *ctx, uint length, uint8_t *src)nettle_hash_update_func;
alias void function(void *ctx, uint length, uint8_t *dst)nettle_hash_digest_func;
alias uint function(uint length)nettle_armor_length_func;
alias void function(void *ctx)nettle_armor_init_func;
alias uint function(void *ctx, uint8_t *dst, uint src_length, uint8_t *src)nettle_armor_encode_update_func;
alias uint function(void *ctx, uint8_t *dst)nettle_armor_encode_final_func;
alias int function(void *ctx, uint *dst_length, uint8_t *dst, uint src_length, uint8_t *src)nettle_armor_decode_update_func;
alias int function(void *ctx)nettle_armor_decode_final_func;
alias ubyte uint8_t;
alias uint uint32_t;
alias ulong uint64_t;

alias _N1 __mpz_struct;
alias __mpz_struct [1]mpz_t;
struct _N1
{
}

struct nettle_buffer;
struct sexp_iterator;
struct asn1_der_iterator;